#version 460
#extension GL_EXT_ray_tracing : require

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba8) uniform image2D image;

// [추가] C++에서 연결한 Depth Sampler (Binding 5)
layout(set = 0, binding = 5) uniform sampler2D depthMap; 

// ... (UBO, Light 구조체 등 기존 코드 동일) ...
layout(set = 0, binding = 2, std140) uniform UniformBufferObject {
    mat4 viewInverse;
    mat4 projInverse;
    vec3 cameraPos;
    // ...
} ubo;

// [수정] Payload를 구조체로 변경하여 '거리(hitT)' 정보를 받음
struct HitPayload {
    vec3 color;
    float hitT; // 충돌 거리
};

layout(location = 0) rayPayloadEXT HitPayload payload; // vec3 hitValue -> HitPayload payload
layout(location = 1) rayPayloadEXT bool isShadowed;

void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = ubo.viewInverse * vec4(0,0,0,1);
    vec4 target = ubo.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = ubo.viewInverse * vec4(normalize(target.xyz), 0);

    // 1. 래스터화된 깊이 정보 읽기
    float zBuffer = texture(depthMap, inUV).r;

    // 2. 래스터화된 픽셀의 월드 거리 계산 (간단한 근사)
    // 깊이 버퍼가 1.0이면(초기값) 아주 멀리 있는 것
    float rasterDist = 1e20; // 무한대
    if(zBuffer < 1.0) {
        // 깊이값(NDC)을 이용해 월드 좌표 복원 후 거리 계산
        vec4 clipPos = vec4(d.x, d.y, zBuffer, 1.0);
        vec4 viewPos = ubo.projInverse * clipPos;
        viewPos /= viewPos.w;
        vec4 worldPos = ubo.viewInverse * viewPos;
        rasterDist = distance(origin.xyz, worldPos.xyz);
    }

    // [핵심 최적화] 래스터 물체가 아주 가까이 있다면, 레이를 쏘지 않고 바로 종료!
    // "여기는 이미 래스터화로 그렸으니, 값비싼 레이 트레이싱은 하지 마라"
    if (rasterDist < 1000.0) { // 적절한 거리 임계값 (혹은 zBuffer < 1.0 체크)
        // 아무것도 안 하고 함수 종료 -> 기존 래스터 이미지 유지됨
        // GPU는 여기서 멈추므로 TraceRay 비용이 0이 됨!
        return; 
    }

    // 3. 레이 트레이싱 수행
    payload.color = vec3(0.0);
    payload.hitT = 0.0; // 초기화

    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin.xyz, 0.001, direction.xyz, 1e20, 0);

    // 4. [핵심] 깊이 비교 (Depth Test)
    // 레이가 무언가에 맞았고(hitT > 0), 그 거리가 래스터화된 벽보다 가깝다면 -> RT 그림
    // 레이가 안 맞았거나, 래스터화된 벽이 더 가깝다면 -> 래스터화 그림 유지 (쓰기 건너뜀)
    
    // [기존 코드]
    // if(payload.hitT > 0.0 && payload.hitT < rasterDist) { 

    // [수정 코드] 깊이 값에 약간의 여유(0.01)를 둡니다.
    // 즉, RT 결과가 래스터화된 벽보다 '최소 0.01만큼' 더 가까울 때만 그립니다.
    // 기존코드는 이론상 rasterDist와 hitT는 같아야 하지만, 부동 소수점 정밀도 오차로 인해 미세하게 값이 달라집니다.
    // RT가 이기는 경우 (hitT < rasterDist): RT 쉐이더가 실행되어 화면을 덮어씁니다. 이때 RT 쉐이더의 그림자 계산(traceRayEXT)에서 자기 자신을 가리는 Self-Shadowing(검은 점) 현상이 발생하여 검게 보입니다.
    // Raster가 이기는 경우 (hitT >= rasterDist): RT가 그리지 않고, 원래의 빨간색 래스터 이미지가 남습니다.
    // 이 두 경우가 픽셀마다 무작위로 번갈아 나타나면서 자글거리는 노이즈처럼 보이는 것입니다.
    // 해결 방법: 깊이 편향(Depth Bias) 추가 / 레이 트레이싱이 래스터화된 결과(배경)를 덮어쓰려면, 물체가 확실히 더 앞에 있을 때만 그리도록 해야 합니다. 아주 미세한 차이는 무시하도록 **여유 값(Epsilon)**을 주어 해결할 수 있습니다.
    if(payload.hitT > 0.0 && payload.hitT < rasterDist - 0.01) {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(payload.color, 1.0));
    } 
    // else: imageStore를 호출하지 않음으로써 기존 배경(래스터화 결과)을 보존
}