#version 460
#extension GL_EXT_ray_tracing : require

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba8) uniform image2D image;

// [추가] C++에서 연결한 Depth Sampler (Binding 5)
layout(set = 0, binding = 5) uniform sampler2D depthMap; 

// ... (UBO, Light 구조체 등 기존 코드 동일) ...
layout(set = 0, binding = 2, std140) uniform UniformBufferObject {
    mat4 viewInverse;
    mat4 projInverse;
    vec3 cameraPos;
    // ...
} ubo;

// [수정] Payload를 구조체로 변경하여 '거리(hitT)' 정보를 받음
struct HitPayload {
    vec3 color;
    float hitT; // 충돌 거리
};

layout(location = 0) rayPayloadEXT HitPayload payload; // vec3 hitValue -> HitPayload payload
layout(location = 1) rayPayloadEXT bool isShadowed;

void main()
{
    // 1. 기본 좌표 계산
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = ubo.viewInverse * vec4(0,0,0,1);
    vec4 target = ubo.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = ubo.viewInverse * vec4(normalize(target.xyz), 0);

    // 2. [핵심] 래스터화된 깊이 읽기 및 Tmax 설정
    float zBuffer = texture(depthMap, inUV).r;
    float tMax = 1e20; // 기본값: 무한대 (허공)

    // 깊이 값이 기록되어 있다면(1.0 미만), 그 거리까지만 레이를 쏨
    if(zBuffer < 1.0) {
        vec4 clipPos = vec4(d.x, d.y, zBuffer, 1.0);
        vec4 viewPos = ubo.projInverse * clipPos;
        viewPos /= viewPos.w;
        vec4 worldPos = ubo.viewInverse * viewPos;
        
        // 0.01은 Z-Fighting 방지용 바이어스(Bias)
        tMax = distance(origin.xyz, worldPos.xyz) - 0.01; 
    }

    // 초기화
    payload.color = vec3(0.0);
    payload.hitT = 0.0;

    // 3. [핵심] 레이 발사 (최적화 적용)
    // - Mask 0x01: RT 물체하고만 충돌 검사 (Raster 물체는 무시 -> 중복 렌더링 방지)
    // - tMax: 래스터화된 벽 뒤로는 검사하지 않음 (불필요한 연산 방지)
    traceRayEXT(topLevelAS, 
        gl_RayFlagsOpaqueEXT, 
        0x01,             // <--- Mask 수정 (0xFF -> 0x01)
        0, 0, 0, 
        origin.xyz, 0.001, 
        direction.xyz, 
        tMax,             // <--- 거리 제한 수정 (1e16 -> tMax)
        0
    );

    // 4. 결과 합성
    // 레이가 tMax보다 가까운 RT 물체에 맞았을 때만 그림
    if(payload.hitT > 0.0) {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(payload.color, 1.0));
    }
    // else: 아무것도 안 했으므로 미리 복사해둔 래스터화 배경(Storage Image)이 유지됨
}